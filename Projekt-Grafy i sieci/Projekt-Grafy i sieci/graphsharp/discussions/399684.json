[
  {
    "Id": "927799",
    "ThreadId": "399684",
    "Html": "\r\n<p>First - great thanks to the devs of graphsharp! It's an awesome library and very easy to use.<br>\r\n<br>\r\nHowever I ran into the following problem. After removing vertices and edges from the graph model and adding new ones, the library seems to randomly throw TargetInvocationException. This occurs during layout update animation, after a graph has been changed.\r\n Here is the stack trace:<br>\r\n<br>\r\n<span style=\"font-size:10px\">WindowsBase.dll!System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty dp, bool preserveCurrentValue)mscorlib.dll!System.Delegate.DynamicInvokeImpl(object[] args)PresentationCore.dll!System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate\r\n genericHandler, object genericTarget)PresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target)PresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs\r\n routedEventArgs)PresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)PresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs\r\n args)PresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e)<span style=\"color:#ff0000\">GraphSharp.Controls.dll!GraphSharp.Controls.GraphElementBehaviour.HighlightTrigger_Coerce(System.Windows.DependencyObject d, object</span>\r\n baseValue)WindowsBase.dll!System.Windows.DependencyObject.ProcessCoerceValue(System.Windows.DependencyProperty dp, System.Windows.PropertyMetadata metadata, ref System.Windows.EntryIndex entryIndex, ref int targetIndex, ref System.Windows.EffectiveValueEntry\r\n newEntry, ref System.Windows.EffectiveValueEntry oldEntry, ref object oldValue, object baseValue, object controlValue, System.Windows.CoerceValueCallback coerceValueCallback, bool coerceWithDeferredReference, bool coerceWithCurrentValue, bool skipBaseValueChecks)WindowsBase.dll!System.Windows.DependencyObject.UpdateEffectiveValue(System.Windows.EntryIndex\r\n entryIndex, System.Windows.DependencyProperty dp, System.Windows.PropertyMetadata metadata, System.Windows.EffectiveValueEntry oldEntry, ref System.Windows.EffectiveValueEntry newEntry, bool coerceWithDeferredReference, bool coerceWithCurrentValue, System.Windows.OperationType\r\n operationType)PresentationFramework.dll!System.Windows.Data.BindingExpressionBase.Invalidate(bool isASubPropertyChange)PresentationFramework.dll!System.Windows.Data.BindingExpression.TransferValue(object newValue, bool isASubPropertyChange)PresentationFramework.dll!System.Windows.Data.BindingExpression.ScheduleTransfer(bool\r\n isASubPropertyChange)PresentationFramework.dll!MS.Internal.Data.ClrBindingWorker.NewValueAvailable(bool dependencySourcesChanged, bool initialValue, bool isASubPropertyChange)PresentationFramework.dll!MS.Internal.Data.PropertyPathWorker.UpdateSourceValueState(int\r\n k, System.ComponentModel.ICollectionView collectionView, object newValue, bool isASubPropertyChange)PresentationFramework.dll!MS.Internal.Data.PropertyPathWorker.OnDependencyPropertyChanged(System.Windows.DependencyObject d, System.Windows.DependencyProperty\r\n dp, bool isASubPropertyChange)PresentationFramework.dll!MS.Internal.Data.ClrBindingWorker.OnSourceInvalidation(System.Windows.DependencyObject d, System.Windows.DependencyProperty dp, bool isASubPropertyChange)PresentationFramework.dll!System.Windows.Data.BindingExpression.HandlePropertyInvalidation(System.Windows.DependencyObject\r\n d, System.Windows.DependencyPropertyChangedEventArgs args)PresentationFramework.dll!System.Windows.Data.BindingExpressionBase.OnPropertyInvalidation(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs args)PresentationFramework.dll!System.Windows.Data.BindingExpression.OnPropertyInvalidation(System.Windows.DependencyObject\r\n d, System.Windows.DependencyPropertyChangedEventArgs args)WindowsBase.dll!System.Windows.DependentList.InvalidateDependents(System.Windows.DependencyObject source, System.Windows.DependencyPropertyChangedEventArgs sourceArgs)WindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs\r\n args)WindowsBase.dll!System.Windows.DependencyObject.UpdateEffectiveValue(System.Windows.EntryIndex entryIndex, System.Windows.DependencyProperty dp, System.Windows.PropertyMetadata metadata, System.Windows.EffectiveValueEntry oldEntry, ref System.Windows.EffectiveValueEntry\r\n newEntry, bool coerceWithDeferredReference, bool coerceWithCurrentValue, System.Windows.OperationType operationType)WindowsBase.dll!System.Windows.DependencyObject.SetValueCommon(System.Windows.DependencyProperty dp, object value, System.Windows.PropertyMetadata\r\n metadata, bool coerceWithDeferredReference, bool coerceWithCurrentValue, System.Windows.OperationType operationType, bool isInternal)WindowsBase.dll!System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey key, object value)WindowsBase.dll!System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey\r\n dp, bool value)PresentationCore.dll!System.Windows.ReverseInheritProperty.FirePropertyChangeInAncestry(System.Windows.DependencyObject element, bool oldValue, MS.Internal.DeferredElementTreeState treeState, System.Action&lt;System.Windows.DependencyObject,bool&gt;\r\n originChangedAction)PresentationCore.dll!System.Windows.ReverseInheritProperty.FirePropertyChangeInAncestry(System.Windows.DependencyObject element, bool oldValue, MS.Internal.DeferredElementTreeState treeState, System.Action&lt;System.Windows.DependencyObject,bool&gt;\r\n originChangedAction)PresentationCore.dll!System.Windows.ReverseInheritProperty.FirePropertyChangeInAncestry(System.Windows.DependencyObject element, bool oldValue, MS.Internal.DeferredElementTreeState treeState, System.Action&lt;System.Windows.DependencyObject,bool&gt;\r\n originChangedAction)PresentationCore.dll!System.Windows.ReverseInheritProperty.FirePropertyChangeInAncestry(System.Windows.DependencyObject element, bool oldValue, MS.Internal.DeferredElementTreeState treeState, System.Action&lt;System.Windows.DependencyObject,bool&gt;\r\n originChangedAction)PresentationCore.dll!System.Windows.ReverseInheritProperty.FirePropertyChangeInAncestry(System.Windows.DependencyObject element, bool oldValue, MS.Internal.DeferredElementTreeState treeState, System.Action&lt;System.Windows.DependencyObject,bool&gt;\r\n originChangedAction)PresentationCore.dll!System.Windows.ReverseInheritProperty.OnOriginValueChanged(System.Windows.DependencyObject oldOrigin, System.Windows.DependencyObject newOrigin, System.Collections.Generic.IList&lt;System.Windows.DependencyObject&gt;\r\n otherOrigins, ref MS.Internal.DeferredElementTreeState oldTreeState, System.Action&lt;System.Windows.DependencyObject,bool&gt; originChangedAction)PresentationCore.dll!System.Windows.Input.MouseDevice.ChangeMouseOver(System.Windows.IInputElement mouseOver,\r\n int timestamp)PresentationCore.dll!System.Windows.Input.MouseDevice.PreNotifyInput(object sender, System.Windows.Input.NotifyInputEventArgs e)PresentationCore.dll!System.Windows.Input.InputManager.ProcessStagingArea()PresentationCore.dll!System.Windows.Input.InputManager.ProcessInput(System.Windows.Input.InputEventArgs\r\n input)PresentationCore.dll!System.Windows.Input.InputProviderSite.ReportInput(System.Windows.Input.InputReport inputReport)PresentationCore.dll!System.Windows.Interop.HwndMouseInputProvider.ReportInput(System.IntPtr hwnd, System.Windows.Input.InputMode mode,\r\n int timestamp, System.Windows.Input.RawMouseActions actions, int x, int y, int wheel)PresentationCore.dll!System.Windows.Interop.HwndMouseInputProvider.FilterMessage(System.IntPtr hwnd, MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr\r\n lParam, ref bool handled)PresentationCore.dll!System.Windows.Interop.HwndSource.InputFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)WindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int\r\n msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)WindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o)WindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int\r\n numArgs)WindowsBase.dll!MS.Internal.Threading.ExceptionFilterHelper.TryCatchWhen(object source, System.Delegate method, object args, int numArgs, System.Delegate catchHandler)WindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority\r\n priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs)WindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam)[Native to Managed Transition][Managed to Native\r\n Transition]WindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame)WindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame)WindowsBase.dll!System.Windows.Threading.Dispatcher.Run()PresentationFramework.dll!System.Windows.Application.RunDispatcher(object\r\n ignore)PresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window)PresentationFramework.dll!System.Windows.Application.Run(System.Windows.Window window)PresentationFramework.dll!System.Windows.Application.Run()FlowAnalyzer.exe!FlowAnalyzer.App.Main()[Native\r\n to Managed Transition][Managed to Native Transition]mscorlib.dll!System.AppDomain.ExecuteAssembly(string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args)Microsoft.VisualStudio.HostingProcess.Utilities.dll!Microsoft.VisualStudio.HostingProcess.HostProc.RunUsersAssembly()mscorlib.dll!System.Threading.ThreadHelper.ThreadStart_Context(object\r\n state)mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext\r\n executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)mscorlib.dll!System.Threading.ThreadHelper.ThreadStart()[Native\r\n to Managed Transition]&nbsp;</span></p>\r\n<p>Essentially what I have is a directed graph, representing a flow, where certain nodes represent sub-flows. If the user clicks on a node, it is removed from the graph and replaced with a list of subflow vertices and edges that it represents. This is loaded\r\n from XML. Here's a simplified version of the code that I run upon clicking the node:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> LoadSubflow(PocVertex v)\n{\n       XElement subflow = Utilities.getSubFlowNode(v.Element);\n\n       PocVertex start = AddVertices(subflow);\n\n       AddEdges(v, start);\n\n       Graph.RemoveVertex(v);\n\n}\n\n<span style=\"color:blue\">private</span> PocVertex AddVertices(XElement flow)\n{\n       PocVertex startnode = <span style=\"color:blue\">null</span>;\n       IEnumerable&lt;XElement&gt; children = flow.Elements();\n       <span style=\"color:blue\">foreach</span> (XElement child <span style=\"color:blue\">in</span> children)\n       {\n            PocVertex v = <span style=\"color:blue\">new</span> PocVertex(child);\n            Graph.AddVertex(v);\n            <span style=\"color:blue\">if</span> (Utilities.getNodeName(child) == <span style=\"color:#a31515\">&quot;START&quot;</span>)\n            {\n                startnode = v;\n            }\n        <span style=\"color:blue\">return</span> startnode;\n}\n\n<span style=\"color:blue\">private void</span> AddEdges(PocVertex replaced, PocVertex start)\n{\n     <span style=\"color:blue\">foreach</span> (PocEdge edge <span style=\"color:blue\">in</span> replaced.IncomingEdges)\n     {\n          PocEdge newEdge = <span style=\"color:blue\">new</span> PocEdge(edge.Source, start);\n          edge.Source.OutgoingEdges.Add(newEdge);\n          start.IncomingEdges.Add(newEdge);\n          Graph.AddEdge(newEdge);\n     }\n}\n\n</pre>\r\n<pre>EDIT: I found that if I disable the highlight algorithm, no more exceptions are being thrown. I would however like to use the highlight feature.</pre>\r\n</div>\r\n<p>Any help or information about the exception would be greatly appreciated! Thanks!</p>\r\n",
    "PostedDate": "2012-10-16T20:51:10.787-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]