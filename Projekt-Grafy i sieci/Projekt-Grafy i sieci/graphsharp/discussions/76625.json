[
  {
    "Id": "262008",
    "ThreadId": "76625",
    "Html": "<p>Hi guys,</p>\r\n<p>if you allow me one question regarding dynamically adding vertices (and connected edges).<br>My problem is that the newly created vertices are all stacked on top of each other (even though the edges are connected correctly to their assigned vertices - which only becomes visible when manually dragging the vertices a bit apart).</p>\r\n<p>I've included a bit of code - hopefully my problem is more abstract and I am simply doing a typical noobish thinking-mistake in the architecture though :-)<br>I am basically creating an empty graph from my ViewModel and at the same time starting various background-workers which load rdf-data from different sources.<br>The background workers fill a singleton (thread-safe) collection object (EntityCache). When the workers finish the workerCompleted method in the main UI thread triggers a refreshGraph(..)&nbsp; which adds newly added model objects as new vertices to the graph:</p>\r\n<p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\"><br>private</span> <span style=\"color:Blue\">void</span> refreshGraph (<span style=\"color:Blue\">object</span> sender, NotifyCollectionChangedEventArgs eventArgs)\r\n        {\r\n            <span style=\"color:Green\">// handle added items</span>\r\n            <span style=\"color:Blue\">if</span> (eventArgs.Action == NotifyCollectionChangedAction.Add)\r\n            {\r\n                <span style=\"color:Blue\">foreach</span> (EntityViewModel newEntityViewModel <span style=\"color:Blue\">in</span> eventArgs.NewItems)\r\n                {\r\n                    <span style=\"color:Blue\">this</span>.addEntityViewModelToGraph(newEntityViewModel);\r\n                }\r\n                \r\n            }\r\n            <span style=\"color:Green\">// request relayout from the view</span>\r\n            <span style=\"color:Blue\">this</span>.OnEventRequestRelayoutGraph(<span style=\"color:Blue\">new</span> EventArgs());\r\n        }\r\n\r\n\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;summary&gt;</span>\r\n        <span style=\"color:Gray\">///</span><span style=\"color:Green\"> Adds an entity to the graph.</span>\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;/summary&gt;</span>\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;param name=&quot;entity&quot;&gt;</span><span style=\"color:Green\">The entity.&lt;/param&gt;</span>\r\n        <span style=\"color:Blue\">private</span> <span style=\"color:Blue\">void</span> addEntityViewModelToGraph(EntityViewModel entityViewModel)\r\n        {\r\n            <span style=\"color:Blue\">if</span> (entityViewModel != <span style=\"color:Blue\">null</span>)\r\n            {\r\n                <span style=\"color:Gray\">///</span><span style=\"color:Green\">/ create a new EntityViewModel from this entity (or get from cache)</span>\r\n                entityViewModel = <span style=\"color:Blue\">this</span>.getCachedEntityViewModel(entityViewModel);\r\n                <span style=\"color:Blue\">this</span>._graphToVisualize.AddVertex(entityViewModel);\r\n\r\n                <span style=\"color:Green\">// now check if there are references in object-properties we can add too</span>\r\n                Dictionary&lt;<span style=\"color:Blue\">string</span>, <span style=\"color:Blue\">object</span>&gt; properties = entityViewModel.entity.GetAllProperties();\r\n                <span style=\"color:Blue\">foreach</span> (KeyValuePair&lt;<span style=\"color:Blue\">string</span>, <span style=\"color:Blue\">object</span>&gt; kvpProperty <span style=\"color:Blue\">in</span> properties)\r\n                {\r\n                    <span style=\"color:Green\">// check if it is an object property</span>\r\n                    Property propertyType = entityViewModel.entity.GetPropertyType(kvpProperty.Key);\r\n                    <span style=\"color:Blue\">if</span> (entityViewModel.entity.GetPropertyType(kvpProperty.Key).IsObjectProperty())\r\n                    {\r\n                        <span style=\"color:Green\">// if the object property is a list of entities add all</span>\r\n                        <span style=\"color:Blue\">if</span> (kvpProperty.Value.GetType() ==\r\n                            <span style=\"color:Blue\">typeof</span>(List&lt;IEntity&gt;))\r\n                        {\r\n                            <span style=\"color:Blue\">foreach</span> (IEntity connectedEntity <span style=\"color:Blue\">in</span> (IList&lt;IEntity&gt;)kvpProperty.Value)\r\n                            {\r\n                                    <span style=\"color:Green\">// create a new EntityViewModel from this entity (or get cached)</span>\r\n                                    EntityViewModel connectedEntityViewModel =\r\n                                        <span style=\"color:Blue\">this</span>.getCachedEntityViewModel(connectedEntity);\r\n                                    Edge&lt;EntityViewModel&gt; e2 = <span style=\"color:Blue\">new</span> Edge&lt;EntityViewModel&gt;(entityViewModel,\r\n                                                                                         connectedEntityViewModel);\r\n                                    <span style=\"color:Blue\">this</span>._graphToVisualize.AddVerticesAndEdge(e2);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                <span style=\"color:Green\">// raise property changed to View</span>\r\n                RaisePropertyChanged(<span style=\"color:#A31515\">&quot;GraphToVisualize&quot;</span>);\r\n            }\r\n        }\r\n</pre>\r\n</div>\r\n</p>\r\n<p>When the vertices ended up all stucked up I tried to manually force a relayout of the graphControl in the view by raising an event from viewModel to view.<br>(As you can see in the first method (last statement)).<br>This unfortunately led to the following exception in FSAAlgorithms.cs:HorizontalImproved()</p>\r\n<p>\r\n<pre><br>System.ArgumentOutOfRangeException was unhandled\r\n  Message=&quot;Index was out of range. Must be non-negative and less than the size of the collection.\\r\\nParameter name: index&quot;\r\n  Source=&quot;mscorlib&quot;\r\n  ParamName=&quot;index&quot;\r\n  StackTrace:\r\n       at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)\r\n       at System.ThrowHelper.ThrowArgumentOutOfRangeException()\r\n       at System.Collections.Generic.List`1.get_Item(Int32 index)\r\n       at GraphSharp.Algorithms.OverlapRemoval.FSAAlgorithm`2.HorizontalImproved() in D:\\ConSenseCode\\ConSense\\_foreignSvn\\GraphSharp\\Graph#\\Algorithms\\OverlapRemoval\\FSAAlgorithm.cs:line 164\r\n       at GraphSharp.Algorithms.OverlapRemoval.FSAAlgorithm`2.RemoveOverlap() in D:\\ConSenseCode\\ConSense\\_foreignSvn\\GraphSharp\\Graph#\\Algorithms\\OverlapRemoval\\FSAAlgorithm.cs:line 35\r\n       at GraphSharp.Algorithms.OverlapRemoval.OverlapRemovalAlgorithmBase`2.InternalCompute() in D:\\ConSenseCode\\ConSense\\_foreignSvn\\GraphSharp\\Graph#\\Algorithms\\OverlapRemoval\\OverlapRemovalAlgorithmBase.cs:line 48\r\n       at GraphSharp.Algorithms.AlgorithmBase.Compute() in D:\\ConSenseCode\\ConSense\\_foreignSvn\\GraphSharp\\Graph#\\Algorithms\\AlgorithmBase.cs:line 36\r\n      [.. left the rest of the stacktrace out]</pre>\r\n</p>\r\n<p>Really at a loss at what to do here.<br>I could imagine the two problems are a bit unrelated with the second being due to some threading problem in my architecture, but the first?<br>Why isnt the graph just laying out the newly added vertices correctly - I mean obviously updating the ViewModel gets noticed by the graphControl, as there ARE vertices shown in the first place.</p>\r\n<p>&nbsp;</p>\r\n<p>Cheers and thank you a bunch for any input on this,<br>Hinnerk</p>",
    "PostedDate": "2009-11-30T12:52:36.517-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "262015",
    "ThreadId": "76625",
    "Html": "<p>Hmmm - writing the above got me thinking about the Exception in FSAAlgorithm.cs (as I am actually using LinLog and not FSA).<br>Tturns out if I switch to FSA no exception is thrown (but the vertices still stay stacked up - even though calling Relayout() ).</p>\r\n<p>Additionally calling RecalculateEdgeRouting() on the graphControl (in place of ReLayout()) throws an&nbsp;</p>\r\n<pre>ArgumentOutOfRangeException </pre>\r\n<p>as well - in this case both with LinLog and FSA.</p>",
    "PostedDate": "2009-11-30T13:05:54.543-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "262392",
    "ThreadId": "76625",
    "Html": "<p>Alright, so changing the layoutAlgorithmType to EfficientSugiyama leads to the expected behavior.</p>\r\n<p>Is it a design mistake on my side, or are Circular, ISOM, EfficientSugiyama and Tree the only mutable layouts? <br>I didnt even consider that at first as e.g. FSA also seems to register for change events to the itemSource.<br>Maybe you could give me some rough estimation on the required effort and a starting point to implement this in a different layout as well?</p>\r\n<p>Thanks,<br>Hinnerk</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-12-01T10:47:35.993-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "266844",
    "ThreadId": "76625",
    "Html": "<p>Thanks Hinnerk,</p>\r\n<p>I was stumped on the same problem using Tree instead of EfficientSugiyama!</p>\r\n<p>Andrew.</p>",
    "PostedDate": "2009-12-13T17:20:51.983-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]