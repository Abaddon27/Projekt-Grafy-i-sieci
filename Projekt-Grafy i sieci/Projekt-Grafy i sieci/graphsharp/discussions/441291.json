[
  {
    "Id": "1034529",
    "ThreadId": "441291",
    "Html": "I think there is a flaw in the implementation of DoNotificationLayout() in GraphLayout.GraphElements.cs (see code quoted below). This method is called whenever a graph mutation has occurred. I believe the intention is that, if multiple graph mutations occur in rapid succession, then calling OnMutation() and ContinueLayout() to redo the layout is deferred until _notificationLayoutDelay (5ms) after the most recent mutation.\r<br />\n<br />\nHowever, the synchronization on _notificationSyncRoot at the start of the method and around the whole of the DoWork delegate means that if a 2nd mutation occurs within 5ms of the previous one, DoNotificationLayout() will actually block the caller until the initial delay has elapsed, rather than returning immediately as I believe might be intended.\r<br />\n<br />\nThis bug isn't very noticeable. Mutations that occur within the same Windows message pump cycle will still be batched, because  _worker.RunWorkerCompleted will not be invoked until the caller returns control to the message pump. But it does introduce a 5ms delay into code that changes the underlying graph and breaks the batching of quickfire updates in different message pump cycles.\r<br />\n<br />\nA fix is to replace<br />\n<pre><code>Thread.Sleep(_notificationLayoutDelay);</code></pre>\n\nwith<br />\n<pre><code>Monitor.Wait(_notificationSyncRoot, _notificationLayoutDelay);</code></pre>\n\nin the code below, which releases the lock during the Sleep.\r<br />\n<br />\nHere is the current code:<br />\n<pre><code>private void DoNotificationLayout()\n        {\n            lock (_notificationSyncRoot)\n            {\n                _lastNotificationTimestamp = DateTime.Now;\n            }\n            if (_worker != null)\n                return;\n\n            _worker = new BackgroundWorker();\n            _worker.DoWork += (s, e) =&gt;\n            {\n                var w = (BackgroundWorker)s;\n                lock (_notificationSyncRoot)\n                {\n                    while ((DateTime.Now - _lastNotificationTimestamp) &lt; _notificationLayoutDelay)\n                    {\n                        Thread.Sleep(_notificationLayoutDelay);\n                        if (w.CancellationPending)\n                            break;\n                    }\n                }\n            };\n            _worker.RunWorkerCompleted += (s, e) =&gt;\n            {\n                _worker = null;\n                OnMutation();\n                ContinueLayout();\n                if (HighlightAlgorithm != null)\n                    HighlightAlgorithm.ResetHighlight();\n            };\n            _worker.RunWorkerAsync();\n        }</code></pre>\n\n",
    "PostedDate": "2013-04-23T06:39:07.417-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]